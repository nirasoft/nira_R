{
    "collab_server" : "",
    "contents" : "\n\n  # Header\n  # Filename:       store.group.R\n  # Description:    This file mainly defines a reference class named STORE.GROUP that Contains\n  #                 the data of a number of stores and manages them.\n  #                 For more information about the class, read the class documentation.\n  # Author:         Nima Ramezani Taghiabadi\n  # Email:          nima.ramezani@cba.com.au\n  # Start Date:     29 January 2016\n  # Last Revision:  14 September 2016\n  # Version:        2.2.2\n#\n\n\n# Version History:\n\n# Version   Date               Action\n# ----------------------------------\n# 2.1.1     29 July 2016       Availability data added. Method get.store() modified to accommodate availability as a new data column\n# 2.1.2     30 August 2016     Property nDays Ahead added to sg.settings. Compatible to virtual.store version 4.5.0\n# 2.1.3     12 September 2016  Argument 'store.ids' added to method run.optimal()\n# 2.2.0     13 September 2016  Method get.store() modified: Specific settings are read from 'spec' table and put in store settings\n# 2.2.1     13 September 2016  Method save.settings() added. Saves SEG and Base Stock parameters for each store in the list in a given csv file\n# 2.2.2     14 September 2016  Argument 'base' added to method gen.report()\n\n\nlibrary(timeDate)\nlibrary(niragen)\nlibrary(nira.timser)\n\n\ndefaultSpecColumns = list(ID = \"ID\", Capacity = 'Capacity', Initial.Balance = \"InitialBalance\",\n                          Order.Fee.InRoster = \"Standard\", Order.Fee.OffRoster = \"Emergency\")\n\n# Definition of Store Group Settings:\n#' @exportClass SG.SETTINGS\n#' @export SG.SETTINGS\nSG.SETTINGS <- setRefClass(\"SG.SETTINGS\", fields = list(\n  # Store IDs are supposed to be rownames of the spec table\n  capacities = 'numeric',\n  costs      = 'matrix',\n  weights    = 'matrix',\n  roster     = 'matrix',\n  lead.time  = 'integer',\n  max.off.srv = 'integer',\n  nDaysAhead  = 'integer',\n  hc.rate    = 'numeric',\n  base.stock = 'numeric',\n  es.penalty = 'numeric',\n  serr.gain  = 'numeric',\n  top.up     = 'numeric')  , methods = list(\n\n    initialize = function(row_names = c(), col_names = c(), ...){\n      callSuper(...)\n      if (!is.empty(row_names)){\n        rownames(costs)   <<- row_names\n        rownames(weights) <<- row_names\n        rownames(roster)  <<- row_names\n      }\n      if (!is.empty(col_names)){\n        colnames(costs)   <<- col_names\n        colnames(weights) <<- col_names\n        colnames(roster)  <<- col_names\n        names(capacities) <<- col_names\n      }\n    },\n\n    ext.vs.settings = function(sid){\n      vss = VS.SETTINGS(\n        capacity     = capacities[sid],\n        order.capacity = capacities[sid],\n        order.fee    = costs[,sid],\n        order.weight = weights[,sid],\n        order.roster = as.logical(roster[,sid]),\n        hc.rate      = hc.rate,\n        lead.time    = lead.time,\n        max.off.srv  = max.off.srv,\n        nDaysAhead   = nDaysAhead,\n        es.penalty   = es.penalty,\n        serr.gain    = serr.gain,\n        top.up       = top.up,\n        base.stock   = base.stock)\n      names(vss$order.roster) <- names(roster[,sid])\n      return(vss)\n    },\n\n    embedd.vs.settings = function(vss, sid){\n      capacities[sid] <<- vss$capacity\n      costs[,sid]     <<- vss$order.fee\n      weights[,sid]   <<- vss$order.weight\n      roster[,sid]    <<- vss$order.roster\n      #hc.rate        <<- vss$hc.rate\n      #lead.time      <<- vss$lead.time\n      #es.penalty     <<- vss$es.penalty\n      #top.up         <<- vss$top.up\n      #base.stock     <<- vss$base.stock\n    },\n\n    read.roster = function(filename, ...){\n      RSTR  = read.csv(filename, as.is = T, row.names = 1, check.names = F)\n      dates = char2Time(rownames(RSTR))\n      rownames(RSTR) <- time2Char(dates)\n      verify(as.matrix(RSTR), names_include = names(roster), varname = filename)\n      rows = intersect(rownames(RSTR),rownames(roster))\n      cols = intersect(colnames(RSTR),colnames(roster))\n      roster[rows, cols] <<- as.matrix(RSTR[rows, cols])\n      apply.roster(rost = roster, ...)\n    },\n\n    write.roster = function(filename, period = sequence(nrow(roster)), store_ids = colnames(roster), update = F){\n      r = roster[period, store_ids, drop = F]\n      if (update){RSTR  = read.csv(filename, as.is = T, row.names = 1, check.names = F)\n      for (sid in store_ids){RSTR[rownames(r), sid] <- r[, sid]}\n      write.csv(RSTR, filename)\n      } else {write.csv(r, filename)}\n    },\n\n    # argument f_rost is a matrix of logicals nrow = N.store, ncol = 14\n    # todo: verfications\n    apply.roster.fortnightly = function(time, start, end, f_rost, in_roster_fee, off_roster_fee, in_roster_weight, off_roster_weight){\n      ns   = nrow(f_rost)\n      sids = rownames(f_rost)\n      if (length(in_roster_fee) == 1){in_roster_fee = rep(in_roster_fee, ns)} else {assert(length(in_roster_fee) == ns, \"The length of argument 'in_roster_fee' does not match 'f_rost'\", match.call()[[1]])}\n      if (length(off_roster_fee) == 1){off_roster_fee = rep(off_roster_fee, ns)} else {assert(length(off_roster_fee) == ns, \"The length of argument 'off_roster_fee' does not match 'f_rost'\", match.call()[[1]])}\n      if (length(in_roster_weight) == 1){in_roster_weight = rep(in_roster_weight, ns)} else {assert(length(in_roster_weight) == ns, \"The length of argument 'in_roster_weight' does not match 'f_rost'\", match.call()[[1]])}\n      if (length(off_roster_weight) == 1){off_roster_weight = rep(off_roster_weight, ns)} else {assert(length(off_roster_weight) == ns, \"The length of argument 'off_roster_weight' does not match 'f_rost'\", match.call()[[1]])}\n      names(in_roster_fee) = sids\n      names(off_roster_fee) = sids\n      names(in_roster_weight) = sids\n      names(off_roster_weight) = sids\n\n      for (i in sids){\n        vss = ext.vs.settings(i)\n        vss$apply.roster.fortnightly(time, start = start, end = end, f_rost = f_rost[i,], in_roster_fee = in_roster_fee[i], off_roster_fee = off_roster_fee[i], in_roster_weight = in_roster_weight[i], off_roster_weight = off_roster_weight[i])\n        embedd.vs.settings(vss, i)\n      }\n    } ,\n\n    apply.roster = function(rost, in_roster_fee, off_roster_fee, in_roster_weight, off_roster_weight){\n      verify(rost, c('data.frame','matrix', 'numeric', 'integer', 'logical'), dims = dim(costs), varname = 'rost', names_identical = names(costs), rownames_identical = rownames(costs))\n      ns   = ncol(rost)\n      sids = colnames(rost)\n      if (length(in_roster_fee) == 1){in_roster_fee = rep(in_roster_fee, ns)} else {assert(length(in_roster_fee) == ns, \"The length of argument 'in_roster_fee' does not match 'f_rost'\", match.call()[[1]])}\n      if (length(off_roster_fee) == 1){off_roster_fee = rep(off_roster_fee, ns)} else {assert(length(off_roster_fee) == ns, \"The length of argument 'off_roster_fee' does not match 'f_rost'\", match.call()[[1]])}\n      if (length(in_roster_weight) == 1){in_roster_weight = rep(in_roster_weight, ns)} else {assert(length(in_roster_weight) == ns, \"The length of argument 'in_roster_weight' does not match 'f_rost'\", match.call()[[1]])}\n      if (length(off_roster_weight) == 1){off_roster_weight = rep(off_roster_weight, ns)} else {assert(length(off_roster_weight) == ns, \"The length of argument 'off_roster_weight' does not match 'f_rost'\", match.call()[[1]])}\n      names(in_roster_fee) = sids\n      names(off_roster_fee) = sids\n      names(in_roster_weight) = sids\n      names(off_roster_weight) = sids\n\n      for (i in sids){\n        vss = ext.vs.settings(i)\n        vss$apply.roster(rost = rost[,i], in_roster_fee = in_roster_fee[i], off_roster_fee = off_roster_fee[i], in_roster_weight = in_roster_weight[i], off_roster_weight = off_roster_weight[i])\n        embedd.vs.settings(vss, i)\n      }\n    },\n\n    forbid_weekends = function(time){\n      dow = dayOfWeek(time)\n      roster[dow %in% c('Sat', 'Sun'),] <<- NA\n    },\n\n    free.roster = function(cost = NULL){\n      roster[,] <<- T\n      if (!is.null(cost)){costs[,]  <<- cost}\n    }\n  ))\n\n#' @export\nbuild.spec = function(specset, spec_columns){\n  verify(spec_columns, c(\"list\", \"character\"))\n\n  permit = names(defaultSpecColumns) %in% names(spec_columns)\n  assert(sum(!permit) == 0,\n         \"Argument 'spec_columns' must specify all required fields. These columns are missing: \"\n         %+% paste(names(defaultSpecColumns[!permit]), collapse = \" , \"), err_src = match.call()[[1]])\n  verify(specset, 'data.frame')\n  names.specset = names(specset)\n\n  permit = spec_columns %in% names.specset\n  assert(sum(!permit) == 0,\n         \"Argument 'specset' must contain all the fields specified by argument 'spec_columns'. These columns are missing: \"\n         %+% paste(spec_columns[!permit], collapse = \" , \"), err_src = match.call()[[1]])\n\n  names(names.specset) <- names.specset\n  names.specset[names.specset[as.character(spec_columns)]] <- names(spec_columns)\n  names(specset) <- names.specset\n  rownames(specset) <- specset$ID\n  return(specset)\n}\n\n\n# Creating a STORE.GROUP class\n#' A Reference Class representing a group of stores.\n#'\n#' @field N.store An integer representing the number of stores in the group\n# N.store: integer containing the number of stores in the group\n# demand: a time series object containing the demands of all the stores in the group\n# order: a time series object containing the orders of all the stores in the group\n# spec: a data.frame containing the specifications of each store\n#'\n#' @export STORE.GROUP\n#' @exportClass STORE.GROUP\nSTORE.GROUP <- setRefClass(\"STORE.GROUP\",\n                           fields = list(\n                             name              = \"character\",\n                             time.zone         = \"character\",\n                             N.store           = \"integer\",\n                             demand            = \"TIME.SERIES\",\n                             order             = \"TIME.SERIES\",\n                             balance           = \"TIME.SERIES\",\n                             order.return      = \"TIME.SERIES\",\n                             holding.cost      = \"TIME.SERIES\",\n                             order.cost        = \"TIME.SERIES\",\n                             total.cost        = \"TIME.SERIES\",\n\n                             pred              = \"TIME.SERIES\",\n                             error             = \"TIME.SERIES\",\n\n                             spec              = \"data.frame\",\n                             report            = \"data.frame\",\n                             availability      = \"data.frame\",\n                             selected          = \"character\",\n\n                             settings          = \"SG.SETTINGS\",\n                             stores            = 'list'\n                           ),\n\n                           methods = list(\n                             # The constructor can either get a list of virtual stores or\n                             # a list containing spec, demand and orders\n                             # the vs_list must be a list. Any other type is not accepted.\n                             initialize = function(timeset = NULL, demandset = numeric(), orderset = numeric(), specset = data.frame(),\n                                                   balances = NULL, returns = NULL, predset = numeric(), errorset = numeric(), time_format = \"%d/%m/%Y\", vs_list = list(),\n                                                   sg_settings = NULL, spec_columns = defaultSpecColumns, time_zone = \"GMT\", ...){\n                               # todo: verifications\n\n                               callSuper(...)\n\n                               if (!is.null(timeset)){\n                                 N.store <<- nrow(specset)\n                                 N.int = length(timeset)\n\n                                 timeset   = verify(timeset, c('NULL', 'character', 'factor', 'timeDate', 'Date', 'POSIXt', 'POSIXct', 'POSIXlt'))\n                                 demandset = verify(demandset, c('numeric', 'data.frame', 'matrix'), dims = c(N.int, N.store))\n                                 orderset  = verify(orderset, c('numeric', 'data.frame', 'matrix'), dims = c(N.int, N.store))\n                                 balances  = verify(balances, c('NULL', 'numeric', 'data.frame', 'matrix'), dims = c(N.int, N.store))\n                                 returns   = verify(returns, c('NULL', 'numeric', 'data.frame', 'matrix'), dims = c(N.int, N.store))\n\n                                 spec    <<- build.spec(specset, spec_columns)\n                                 store.ids = rownames(spec)\n                                 demandset = try(demandset[, store.ids, drop = F], silent = T)\n                                 verify(demandset, err_msg = \"Store IDs do not match: demandset and specset!\", err_src = match.call()[[1]])\n                                 orderset  = try(orderset[, store.ids, drop = F], silent = T)\n                                 verify(demandset, err_msg = \"Store IDs do not match: orderset and specset!\", err_src = match.call()[[1]])\n\n                                 if (!class(balances) == 'NULL'){\n                                   balances = try(balances[, store.ids, drop = F], silent = T)\n                                   verify(balances, err_msg = \"Store IDs do not match: balances and specset!\", err_src = match.call()[[1]])\n                                 }\n                                 if (!class(returns)  == 'NULL'){\n                                   returns = try(returns[, store.ids, drop = F], silent = T)\n                                   verify(returns, err_msg = \"Store IDs do not match: returns and specset!\", err_src = match.call()[[1]])\n                                 }\n\n                                 # dfempty <- data.frame.na(nrow = length(timeset), ncol = N.store, col_names = spec[, 'ID'])\n                                 time.zone <<- time_zone\n                                 tc = time2Char(timeset)\n\n                                 demand  <<- TIME.SERIES(timeset = timeset, dataset = demandset[tc, store.ids], format = time_format, name = 'demand', zone = time.zone, center = time.zone)\n                                 order   <<- TIME.SERIES(timeset = timeset, dataset = orderset[tc, store.ids], format  = time_format, name = 'order', zone = time.zone, center = time.zone)\n\n                                 pred    <<- TIME.SERIES(timeset = timeset, dataset = predset[tc, intersect(store.ids, names(predset))],  format = time_format, name = 'demand.pred', zone = time.zone, center = time.zone)\n                                 error   <<- TIME.SERIES(timeset = timeset, dataset = errorset[tc, intersect(store.ids, names(predset))], format = time_format, name = 'demand.pred.error', zone = time.zone, center = time.zone)\n\n                                 selected <<- rownames(spec)[1]\n                                 reset(balances, returns)\n\n                                 if(class(sg_settings) == \"SG.SETTINGS\"){settings <<- sg_settings}\n                                 else {\n                                   settings    <<- new('SG.SETTINGS',\n                                                       capacities = spec$Capacity,\n                                                       costs   = repeat.row(spec$Order.Fee.InRoster, demand$N.int),\n                                                       weights = repeat.row(spec$Order.Fee.OffRoster, demand$N.int),\n                                                       roster  = matrix(1, demand$N.int, ncol = N.store), hc.rate = 0.0225/365,\n                                                       lead.time = as.integer(1), max.off.srv = as.integer(60), nDaysAhead = as.integer(60), es.penalty   = 10000,  top.up  = 0, base.stock = 0, serr.gain = 1.0,\n                                                       row_names = rownames(demand$data), col_names = rownames(spec))\n                                 }\n\n                                 clear.stores()\n                               } # if timeset is not given an empty object is created\n                               # todo: add construction from vs_list from previous versions\n                             },\n\n                             remove.stores = function(store_ids = sequence(N.store)){\n                               verify(store_ids, 'character', varname = 'store_ids')\n                               NC = which(rownames(spec) %in% store_ids)\n                               if (length(NC) > 0){spec <<- spec[- NC, , drop = F]}\n                               demand$remove.figures(store_ids)\n                               balance$remove.figures(store_ids)\n                               order$remove.figures(store_ids)\n                               order.return$remove.figures(store_ids)\n                               holding.cost$remove.figures(store_ids)\n                               order.cost$remove.figures(store_ids)\n                               total.cost$remove.figures(store_ids)\n                               pred$remove.figures(store_ids)\n                               error$remove.figures(store_ids)\n\n                               NC = which(colnames(settings$roster) %in% store_ids)\n                               if (length(NC) > 0){\n                                 settings$costs   <<- settings$costs[, - NC, drop = F]\n                                 settings$roster  <<- settings$roster[, - NC, drop = F]\n                                 settings$weights <<- settings$weights[, - NC, drop = F]\n                               }\n                               N.store <<- nrow(spec)\n\n                               for (sid in store_ids){stores[[sid]] <<- NULL}\n                             },\n\n                             fortnight.order.counts = function(period = order$stn:order$etn){\n                               foc = matrix(nrow = 0, ncol = 14)\n                               for (sid in colnames(data$demand)){\n                                 FDY    = fday(demand$time)[period]\n                                 t      = tabulate(1 + FDY[which(order$data[period, sid] > 0)])\n                                 foc = rbind(foc, c(t[-1], rep(0, 14 - length(t)), t[1]))\n                               }\n                               colnames(foc)   = fdlabel\n                               rownames(foc)   = rownames(spec)\n                               return(foc)\n                             },\n\n                             fit.fortnight.roster = function(period = order$stn:order$etn, threshold = 0.7, forbid_weekends = T){\n                               roster = matrix(0, nrow = N.store, ncol = 14)\n                               if (forbid_weekends){roster[, c(6,7,13,14)] = NA}\n                               colnames(roster) = fdlabel\n                               rownames(roster) = rownames(spec)\n\n                               foc = fortnight.order.counts(period = period)\n\n                               for (i in 1:N.store){\n                                 ttc = tab.top.cumulative(foc[i,], threshold = threshold)\n                                 roster[i, ttc] = 1\n                               }\n                               return(roster)\n                             },\n\n                             fill.stores = function(store_ids = rownames(spec)){\n                               assert(store_ids, 'character', range = rownames(spec), varname = 'store_ids')\n                               for (sid in store_ids){stores[[sid]] <<- get.store(sid)}\n                             },\n\n                             get.store = function(store_id, silent = F, ...){\n                               verify(store_id, 'character', range = rownames(spec), varname = 'store_id', lengths = 1)\n\n                               if (!silent){cat(store_id,': Convert to VIRTUAL.STORE object ... ')}\n\n                               config = settings$ext.vs.settings(store_id)\n\n                               # Specific Settings:\n                               s1 = spec[ATM_id, 'SEG']\n                               s2 = spec[ATM_id, 'Base']\n                               if (!is.null(s1)) {if (!is.na(s1)) {config$serr.gain   = s1}}\n                               if (!is.null(s2)) {if (!is.na(s2)) {config$base.stock  = s2}}\n\n                               peri   = spec[store_id,'IB.Date.Num']:length(demand$time)\n\n                               config$order.fee   = config$order.fee[peri]\n                               config$order.weight = config$order.weight[peri]\n                               config$order.roster = config$order.roster[peri]\n\n                               vs = VIRTUAL.STORE(demand$time[peri], demand$data[peri, store_id], initial_balance = spec[store_id, 'Initial.Balance'],\n                                                  orderset = order$data[peri, store_id], ID = store_id,\n                                                  name = as.character(spec[store_id, 'Name']), vs_settings = config, center = time.zone, ...)\n                               if (!inherits(pred$data[peri, store_id], 'NULL') & !inherits(error$data[peri,store_id], 'NULL')){\n                                 vs$data$forec = pred$data[peri, store_id]\n                                 vs$data$forec[vs$data$forec < 0] <- 0\n                                 vs$data$fserr = error$data[peri, store_id]*config$serr.gain\n                               }\n                               # todo: jump to store group ctn (transfer balances, returns and costs to the get.store) before returning the get.store object\n                               # Availability:\n                               Ak      <- availability[availability$STOREID == store_id,]\n                               dates.A <- as.character(Ak$Date)\n                               Ak      <- Ak[!duplicated(dates.A),]\n                               dates.A <- unique(dates.A)\n                               rownames(Ak) <- dates.A\n                               vs$feed(Ak[,'Availability', drop = F])\n\n                               if (!silent){cat('Done ! \\n')}\n                               return(vs)\n                             },\n\n                             # Argument: srv_cap is a single numeric or a numeric vector of 14 elements\n                             # and contains the daily order replenishment capacities\n                             # (Maximum how many stores can be serviced for each fortnight day)\n                             optimal.fortnight.roster = function(hist = sequence(length(demand)), srv_cap = NULL, gain = 1.0, feasible_roster = NULL){\n                               # The default value for 'hist' will change later\n                               # todo: This function has been customized for special needs of CBA ATM cash optimization project,\n                               #       and needs to be more generic (i.e. order.cost and hold.cost.rate can be a time series for each store)\n                               # todo: support weekly and monthly and annual rosters\n                               # todo: support special days in year\n\n                               verify(feasible_roster, c('matrix', 'numeric', 'logical', 'integer', 'data.frame'), rownames_include = rownames(spec), names_identical = fdlabel, varname = 'feasible_roster')\n                               if (is.null(feasible_roster)){\n                                 feasible_roster = repeat.row(c(1,1,1,1,1,NA,NA,1,1,1,1,1,NA,NA), N.store)\n                                 colnames(feasible_roster) <- fdlabel\n                                 rownames(feasible_roster) <- rownames(spec)\n                               }\n\n                               feasible_roster <- as.matrix(feasible_roster)\n                               feasible_roster[feasible_roster == 0]  <- NA\n\n                               oc = colMeans(settings$costs, na.rm = T)\n                               mds  = gain*apply(demand$data[hist, ,drop = F], 2, function(x) high.pass.mean(x, threshold = 10, na.rm = TRUE))\n                               sds  = apply(demand$data[hist, ,drop = F], 2, function(x) high.pass.sd(x, threshold = 10, na.rm = TRUE))\n\n                               QSS = sqrt(2*oc*mds/settings$hc.rate)\n                               idx = QSS > spec$Capacity\n                               QSS[idx]  = spec$Capacity[idx]\n                               strength  = spec$Capacity/mds\n                               freq      = ceiling((14*mds + 2.0*sqrt(14)*sds)/QSS)\n                               freq[is.na(freq)] = 1\n\n                               # freq = QSS/mds\n                               #      for (i in 1:N.store){\n                               #        if (mds[i] > 0){\n                               #          if (freq[i] > 14){freq[i] = 1}\n                               #          else if (freq[i] > 7) {freq[i] = 2}\n                               #          else if (freq[i] > 4) {freq[i] = 3}\n                               #          else if (freq[i] > 3) {freq[i] = 4}\n                               #          else {freq[i] = 6}\n                               #        } else {freq[i] = 0}\n                               #      }\n\n                               if (class(srv_cap) == 'NULL'){\n                                 srv_cap = as.integer(2 + sum(freq)/8)\n                               }\n                               if (length(srv_cap) == 1){srv_cap = rep(srv_cap, 14)} else {assert(length(srv_cap) == 14)}\n\n                               from  = '04-Jan-2010'  # It is a Monday.1\n                               until = '17-Jan-2010'  # It is a Sunday.2\n                               ts    = timeSequence(from = from, to = until, by = 'day')\n\n                               ord    = order(strength)\n                               forca  = rep(1, 14)\n                               RSTR   = c()\n                               DF     = demand$aggregate.seasonal(hist, func = high.pass.mean, seasonality = 'dof') #*****\n                               ordids = rownames(spec)[ord]\n                               for (i in sequence(length(ord))){\n                                 frost = feasible_roster[ordids[i], ] & forca\n                                 m     = ord[i]\n                                 u     = distribute.seasonality(ts, season.values = DF[,m, drop = F], seasonality = 'dof')\n                                 r     = opt.roster(demands = gain*u, freq = freq[m], q = QSS[m], fr = frost)\n                                 indx  = (!is.na(r)) & (r == 1)\n                                 srv_cap[indx] = srv_cap[indx] - 1\n                                 forca[srv_cap < 1] = NA\n                                 r[is.na(r) & !is.na(frost)] = 0\n                                 RSTR = rbind(RSTR, r)\n                               }\n                               colnames(RSTR) = fdlabel\n                               rownames(RSTR) = ordids\n                               rsms = rowSums(RSTR, na.rm = T)\n                               if ((sum(freq[ord] - rsms != 0) > 0) | (sum(rsms == 0) > 0)) {cat('Warning: Some stores may have not received adequate service \\n')}\n                               return(RSTR)\n                             },\n\n                             reset = function(balances = NULL, returns = NULL){\n                               report       <<- data.frame()\n\n                               dfempty       <- data.frame.na(nrow = length(demand$time), ncol = N.store, col_names = rownames(spec))\n                               if (class(balances) == 'NULL'){\n                                 balance      <<- TIME.SERIES(timeset = demand$time, dataset = dfempty, name = \"Balance\", center = time.zone)\n                               } else {\n                                 balances = verify(balances, 'data.frame')\n                                 assert(nrow(balances) == length(demand$time), \"Dimension mismatch!\")\n                                 assert(ncol(balances) == N.store, \"Dimension mismatch!\")\n                                 balance  <<- TIME.SERIES(timeset = demand$time, dataset = balances, name = \"Balance\", center = time.zone)\n                               }\n\n                               if (class(returns) == 'NULL'){\n                                 order.return      <<- TIME.SERIES(timeset = demand$time, dataset = dfempty, name = \"Return\", center = time.zone)\n                               } else {\n                                 returns = verify(returns, 'data.frame')\n                                 assert(nrow(returns) == length(demand$time), \"Dimension mismatch!\")\n                                 assert(ncol(returns) == N.store, \"Dimension mismatch!\")\n                                 order.return  <<- TIME.SERIES(timeset = demand$time, dataset = returns, name = \"Return\", center = time.zone)\n                               }\n\n                               holding.cost <<- TIME.SERIES(timeset = demand$time, dataset = dfempty, name = \"Holding Cost\", center = time.zone)\n                               order.cost   <<- holding.cost$copy()\n                               total.cost   <<- holding.cost$copy()\n                               order.cost$name   <<- \"Service Cost\"\n                               total.cost$name   <<- \"Total Cost\"\n\n                               # for (st in rownames(spec)){balance$data[1,st] <<- spec[st, 'Initial.Balance']}\n                             },\n\n                             clear.stores = function(){\n                               stores <<- list()\n                             },\n\n                             run.optimal = function(start = 1, end = length(demand), fixed_roster = T, silent = T){\n                               if (class(start) %in% valid.time.classes){\n                                 start <- try(as.timeDate(start))\n                                 verify(start, lengths = 1, err_src = match.call()[[1]])\n                               } else {\n                                 verify(start, c('numeric', 'integer'), lengths = 1, range = c(1, length(demand)), err_src = match.call()[[1]])\n                                 start = demand$time[start]\n                               }\n\n                               if (class(end) %in% valid.time.classes){\n                                 end <- try(as.timeDate(end))\n                                 verify(end, lengths = 1, err_src = match.call()[[1]])\n                               } else {\n                                 verify(end, c('numeric', 'integer'), lengths = 1, err_src = match.call()[[1]])\n                                 end = demand$time[end]\n                               }\n\n                               for (i in rownames(spec)){\n                                 vs  = stores[[i]]\n                                 if ('VIRTUAL.STORE' %in% class(vs)){\n                                   cat('Run optimization for Store: ', vs$ID, ' started .... \\n')\n                                   vs$goto(start)\n                                   if (vs$now() == start){# can't run if creation time is after start time\n                                     vs$reset()\n                                     vs$jump.optimal(until = end, fixed_roster = fixed_roster, show = !silent)\n                                     cat('Run optimization for Store: ', vs$ID, ' finished! \\n')\n                                   }\n                                 }\n                               }\n                             },\n\n                             gen.report = function(store.ids = NULL, clear = T, base = NULL){\n                               store.ids  = verify(store.ids, 'character', range = names(stores), default = names(stores), varname = 'store.ids')\n                               base       = verify(base, 'numeric', range = c(0, Inf), default = settings$base.stock, varname = 'base')\n                               rstr  = c()\n                               if (clear)(reset())\n                               for (id in store.ids){\n                                 vs  = stores[[id]]\n\n                                 peri  = vs$stn:vs$ctn\n                                 timc  = time2Char(vs$time[peri])\n                                 rstr  = rbind(rstr, vs$fortnight.order.counts())\n\n                                 report[id, \"HOLD.COST\"] <<- vs$data$Hold.Cost[vs$ctn]\n                                 report[id, \"SRV.COST\"]    <<- vs$data$Order.Cost[vs$ctn]\n                                 report[id, \"TOT.COST\"]    <<- vs$data$Total.Cost[vs$ctn]\n                                 report[id, \"FILL.RATE.BASE\"] <<- vs$fill.rate(threshold = base)\n                                 report[id, \"FILL.RATE.ZERO\"] <<- vs$fill.rate(threshold = 1)\n                                 report[id, \"MIN.BALANCE\"] <<- min(vs$data$Balance[peri], na.rm = T)\n                                 report[id, \"PLANNED\"]     <<- sum(vs$settings$order.roster[peri], na.rm = T)\n                                 report[id, \"CANCELLED\"]   <<- sum((vs$data$Order[peri] == 0) & (vs$settings$order.roster[peri]), na.rm = T)\n                                 report[id, \"EMERGENCY\"]   <<- sum((vs$data$Order[peri] > 0) & (!vs$settings$order.roster[peri]), na.rm = T)\n                                 order$data[timc, id]   <<- vs$data$Order[peri]\n                                 balance$data[timc, id] <<- vs$data$Balance[peri]\n                                 order.return$data[timc, id]  <<- vs$data$Return[peri]\n                                 holding.cost$data[timc, id]  <<- vs$data$Hold.Cost[peri]\n                                 order.cost$data[timc, id]    <<- vs$data$Order.Cost[peri]\n                                 total.cost$data[timc, id]    <<- vs$data$Total.Cost[peri]\n                               }\n\n                               columns = c(colnames(report), fdlabel)\n                               report <<- cbind(report, rstr)\n                               colnames(report) <<- columns\n                             },\n\n                             save.stores = function(path){\n                               for (i in names(stores)){\n                                 vs  = stores[[i]]\n                                 if ('VIRTUAL.STORE' %in% class(vs)){\n                                   write.csv(vs$gen.report(vs$stn:vs$ctn), file = paste0(path, '/', vs$ID, '.csv'), row.names = F)\n                                 }\n                               }\n                             },\n\n                             save.report = function(path, ...){\n                               write.csv(report, file  = paste0(path, '/', name, '.report', '.csv'), ...)\n\n                               TC = total.cost$data\n                               TC = TC[!(rowSums(!is.na(TC)) == 0),]\n                               tc = rownames(TC)\n\n                               write.csv(TC, file = paste0(path, '/', name, '.costs', '.csv'), ...)\n                               write.csv(sg$demand$data[tc,, drop = F],  file = paste0(path, '/', name, '.demands', '.csv'), ...)\n                               write.csv(sg$balance$data[tc,, drop = F],  file = paste0(path, '/', name, '.balances', '.csv'), ...)\n                               write.csv(sg$order$data[tc,, drop = F],  file = paste0(path, '/', name, '.orders', '.csv'), ...)\n                               write.csv(sg$order.return$data[tc,, drop = F],  file = paste0(path, '/', name, '.returns', '.csv'), ...)\n                             },\n\n                             save.settings = function(settings_fn, store_ids = NULL){\n                               store.ids = verify(store_ids, 'character', range = names(stores), default = names(stores), varname = 'store_ids')\n                               options(warn = -1)\n                               sts       = try(read.csv(settings_fn, row.names = 1, as.is = T), silent = T)\n                               options(warn = 0)\n                               if (!inherits(sts, 'data.frame')){sts = data.frame()}\n                               for (i in store.ids){\n                                 sts[i, 'SEG']  = stores[[i]]$settings$serr.gain\n                                 sts[i, 'Base'] = stores[[i]]$settings$base.stock\n                               }\n                               write.csv(sts, file = settings_fn)\n                             },\n\n                             save.forecasts = function(forecast_fn, forerror_fn, store_ids = NULL, from_stores = T){\n                               store.ids = verify(store_ids, 'character', range = names(stores), default = names(stores), varname = 'store_ids')\n                               options(warn = -1)\n                               frc       = try(read.csv(forecast_fn, row.names = 1, as.is = T, check.names = F), silent = T)\n                               err       = try(read.csv(forerror_fn, row.names = 1, as.is = T, check.names = F), silent = T)\n                               options(warn = 0)\n                               if (!inherits(frc, 'data.frame')){frc = data.frame()}\n                               if (!inherits(err, 'data.frame')){err = data.frame()}\n\n                               tcf = rownames(pred$data)\n                               tce = rownames(error$data)\n                               for (i in store.ids){\n                                 if (from_stores){\n                                   a = stores[[i]]$data[, 'forec', drop = F]\n                                   e = stores[[i]]$data[, 'fserr', drop = F]/stores[[i]]$settings$serr.gain\n                                   names(a) <- i\n                                   names(e) <- i\n                                   a = a[!is.na(a[,i]), ,drop = F]\n                                   e = e[!is.na(e[,i]), ,drop = F]\n                                   pred$feed(a)\n                                   error$feed(e)\n                                 }\n\n                                 frc[tcf, i]  = pred$data[tcf, i]\n                                 err[tce, i]  = error$data[tce, i]\n                               }\n                               write.csv(frc, file = forecast_fn)\n                               write.csv(err, file = forerror_fn)\n                             },\n\n                             read.forecasts = function(forecast_fn, forerror_fn, store_ids = NULL, to_stores = T){\n                               store.ids = verify(store_ids, 'character', range = names(stores), default = names(stores), varname = 'store_ids')\n                               options(warn = -1)\n                               frc       = try(read.csv(forecast_fn, row.names = 1, as.is = T, check.names = F), silent = T)\n                               err       = try(read.csv(forerror_fn, row.names = 1, as.is = T, check.names = F), silent = T)\n                               options(warn = 0)\n                               assert(inherits(frc, 'data.frame'), 'File ' %+% forecast_fn %+% 'not found or not valid!')\n                               assert(inherits(err, 'data.frame'), 'File ' %+% forerror_fn %+% 'not found or not valid!')\n                               pred$feed(frc)\n                               error$feed(err)\n\n                               if (to_stores){\n                                 for (i in store.ids){\n                                   a = pred$data[, i, drop = F]\n                                   e = error$data[, i, drop = F]\n                                   names(a) <- 'forec'\n                                   names(e) <- 'fserr'\n\n                                   a = a[!is.na(a[,'forec']), ,drop = F]\n                                   e = e[!is.na(e[,'fserr']), ,drop = F]\n\n                                   tce <- rownames(stores[[i]]$data) %^% rownames(e)\n\n                                   stores[[i]]$feed(a)\n                                   stores[[i]]$feed(e)\n\n                                   stores[[i]]$data[tce, 'fserr'] <<- stores[[i]]$data[tce, 'fserr']*stores[[i]]$settings$serr.gain\n                                 }\n                               }\n                             },\n\n                             run = function(start = 1, end = length(demand), silent = F){\n                               if (class(start) %in% valid.time.classes){\n                                 start <- try(as.timeDate(start))\n                                 verify(start, lengths = 1, err_src = match.call()[[1]])\n                               } else {\n                                 verify(start, c('numeric', 'integer'), lengths = 1, range = c(1, length(demand)), err_src = match.call()[[1]])\n                                 start = demand$time[start]\n                               }\n\n                               if (class(end) %in% valid.time.classes){\n                                 end <- try(as.timeDate(end))\n                                 verify(end, lengths = 1, err_src = match.call()[[1]])\n                               } else {\n                                 verify(end, c('numeric', 'integer'), lengths = 1, err_src = match.call()[[1]])\n                                 end = demand$time[end]\n                               }\n\n                               for (i in names(stores)){\n                                 vs  = stores[[i]]\n                                 if ('VIRTUAL.STORE' %in% class(vs)){\n                                   if (!silent){cat('Run simulation for Store: ', vs$ID, '.... ')}\n                                   vs$goto(start)\n                                   vs$reset()\n                                   vs$goto(end)\n                                   if (!silent){cat('Done! \\n')}\n                                 }\n                               }\n                             },\n\n                             goto = function(...){\n                               for (i in names(stores)){\n                                 vs  = stores[[i]]\n                                 vs$goto(...)\n                               }\n                             },\n\n                             recommend.orders = function(...){\n                               RO = data.frame()\n                               for (i in 1:N.store){\n                                 vs  = stores[[i]]\n                                 if (inherits(vs, 'VIRTUAL.STORE')){\n                                   u = vs$recommend.order(...)\n                                   if (\"list\" %in% class(u)){\n                                     RO[vs$ID, 'Date']   = time.to.cahr(u$time)\n                                     RO[vs$ID, 'Amount'] = u$amount\n                                   }\n                                 }\n                               }\n                               return(RO)\n                             },\n\n                             extend.stores = function(...){\n                               for (i in names(stores)){\n                                 vs  = stores[[i]]\n                                 m   = vs$N.int\n                                 vs$extend(vs_settings = settings$ext.vs.settings(i), ...)\n                               }\n                             },\n\n                             extend = function(forecast_demand = T, fort_roster = NULL, extend_stores = F, ...){\n                               m = demand$N.int\n                               demand$extend(...)\n                               balance$extend(...)\n                               order$extend(...)\n                               order.return$extend(...)\n                               holding.cost$extend(...)\n                               order.cost$extend(...)\n                               total.cost$extend(...)\n                               pred$extend(...)\n                               error$extend(...)\n                               settings$roster  <<- mat.extend(settings$roster, demand$N.int)\n                               settings$weights <<- mat.extend(settings$weights, demand$N.int)\n                               settings$costs   <<- mat.extend(settings$costs, demand$N.int)\n                               new.date.labels = rownames(demand$data)[(m + 1):demand$N.int]\n                               rownames(settings$roster)  <<- rownames(demand$data)\n                               rownames(settings$weights) <<- rownames(demand$data)\n                               rownames(settings$costs)   <<- rownames(demand$data)\n\n                               if (extend_stores){extend.stores(forecast_demand = forecast_demand, ...)}\n\n                               if (!is.null(fort_roster)){\n                                 settings$apply.fort.roster(demand$time, start = m + 1, end = demand$N.int, f_rost = fort_roster,\n                                                            in_roster_fee = spec$Order.Fee.InRoster, off_roster_fee = spec$Order.Fee.OffRoster,\n                                                            in_roster_weight = settings$OrderWeightInRoster, off_roster_weight = settings$OrderWeightOffRoster)\n                               }\n                             },\n\n                             gglvis.motion = function(period = balance$stn:balance$ctn, store_ids = rownames(spec)){\n                               assert(length(period) > 1, \"Given period must have more than one element!\", err_src = match.call()[[1]])\n                               V = TIME.SERIES(center = time.zone)\n                               for(k in store_ids){\n                                 ST = demand[period, k]\n                                 names(ST$data) = 'Demand'\n                                 ST$append(balance$data[period, k], 'Balance')\n                                 ST$append(holding.cost$data[period, k], 'Holding.Cost')\n                                 ST$append(order.cost$data[period, k], 'Order.Cost')\n                                 ST$append(total.cost$data[period, k], 'Total.Cost')\n                                 ST$ID = k\n                                 V = V | ST\n                               }\n                               V$gglvis.motion(xvar = 'Holding.Cost', yvar = 'Order.Cost', sizevar = 'Total.Cost', colorvar = 'Demand')\n                             }\n                           ))\n\n#' @export\n'[.STORE.GROUP' = function(obj, store_ids){\n  if (class(store_ids) %in% c('numeric', 'integer')){store_ids = rownames(obj$spec)[store_ids]}\n  verify(store_ids, 'character', range = rownames(obj$spec), varname = 'store_ids')\n\n  vsl = list()\n  for (sid in store_ids){\n    if (sid %in% names(obj$stores)){vsl = c(vsl, obj$stores[[sid]])} else {\n      vs  = obj$get.store(sid)\n      vsl = c(vsl, vs)\n      obj$stores[[vs$ID]] = vs\n    }\n  }\n  if (length(vsl) == 1){vsl = vsl[[1]]}\n  return(vsl)\n}\n",
    "created" : 1475010124834.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2940808954",
    "id" : "F77447",
    "lastKnownWriteTime" : 1475010176,
    "last_content_update" : 1475010176139,
    "path" : "C:/Users/nimasoft/Dropbox/software/R/packages/nira.storeman/R/store.group.R",
    "project_path" : "R/store.group.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}