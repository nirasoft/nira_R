{
    "collab_server" : "",
    "contents" : "\n\n  # Header\n  # Filename:      inv.tools.R\n  # Description:   Contains various functions including some\n  #                inventory cost prediction models and optimal roster planners.\n  # Author:        Nima Ramezani Taghiabadi\n  # Email :        N.RamezaniTaghiabadi@uws.edu.au\n  # Start Date:    13 January 2016\n  # Last Revision: 15 July 2016\n  # Version:       4.3.1\n\n# Version History:\n#\n# Version    Date          Actions\n# ----------------------------------------------------\n# 4.3.1      15 July 2016  function opt.roster() exported\n\n#' @export\nfutureCostPI <- function (N, B, mu, sigma, P, h, base = 0) {\n  # Given stochastic usage mean and standard deviation and associated costs, predicts future cost per unit time for a desired\n  # replenishment amount after a given amount of time\n  # Input 1: N Number of time intervals ahead from now until the replenishment\n  # Input 2: B Current opening balance or Current amount of inventory (cash in the ATM) (Only used if argument replenish = FALSE)\n\n  p     = rep(0,N)\n  f     = rep(0,N)\n  s.penalty = 0\n  s.holding = 0\n\n  for (i in 1:N){\n    mu.i    = B - i*mu\n    sigma.i = sqrt(i)*sigma\n    z0      = (base - mu.i)/sigma.i\n\n    f[i] = pnorm(z0)\n    if (i == 1){\n      p[i] = f[i]\n    } else{\n      p[i] = f[i] - f[i-1]\n    }\n    s.penalty = s.penalty + (N - i + 1)*p[i]\n    s.holding = s.holding + i*p[i]\n  }\n\n  mu.N    = B - N*mu\n  sigma.N = sqrt(N)*sigma\n  z0      = (base - mu.N)/sigma.N\n  PHI     = pnorm(z0)\n  phi     = exp(- 0.5*z0*z0)/sqrt(2*pi)\n\n  I       = (B + mu.N)*(1 - PHI) + sigma.N*phi\n\n  cost.N  = P*s.penalty + 0.5*h*B*s.holding + 0.5*N*h*I\n  cost    = cost.N/N\n  return(cost)\n}\n\n#' @export\nfutureCostsPI <- function (N, B, mu, sigma, P, h, base = 0) {\n  # Given stochastic usage mean and standard deviation and associated costs, predicts future cost per unit time for a desired\n  # replenishment amount after a given amount of time\n  # Input 1: Q - The amount of replenishment (Only used if argument replenish is TRUE)\n  # Input 2: N - number of time intervals in the future from now for prediction\n  # Input 3: B - cur opening balance or cur amount of inventory (cash in the ATM) (Only used if argument replenish = FALSE)\n\n  assert(length(mu) == N, \"Error\")\n  assert(length(sigma) == N, \"Error\")\n\n  p     = rep(0,N)\n  f     = rep(0,N)\n  s.penalty = 0\n  s.holding = 0\n\n  for (i in 1:N){\n    z0      = (base - mu[i])/sigma[i]\n\n    f[i] = pnorm(z0)\n    if (i == 1){\n      p[i] = f[i]\n    } else{\n      p[i] = f[i] - f[i-1]\n    }\n    s.penalty = s.penalty + (N - i + 1)*p[i]\n    s.holding = s.holding + i*p[i]\n  }\n\n  # mu.N    = mu[N]\n  # sigma.N = sqrt(sum(sigma[1:N]^2))\n\n  # z0      = (base - mu.N)/sigma.N\n  PHI     = pnorm(z0)\n  phi     = exp(- 0.5*z0*z0)/sqrt(2*pi)\n\n  I       = (B + mu[N])*(1 - PHI) + sigma[i]*phi\n\n  cost.N  = P*s.penalty + 0.5*h*B*s.holding + 0.5*N*h*I\n  cost    = cost.N/N\n  return(cost)\n}\n\n# fr : 1  1  NA  NA  1  0  NA\n# a  : 1  0  0   1   1  0  1\n# out: 1  0  NA  NA  0  1  NA\nint.to.roster = function(x, fr){\n  a = as.integer(intToBits(x))\n  y = fr\n  y[!is.na(fr)] = a[sequence(length(y[!is.na(fr)]))]\n  return(y)\n}\n\n# roster.to.int\n\nroster.cost = function(r, q = NA, demands = rep(1.0, 14)){\n  r = as.logical(r)\n  s = numeric()\n  j = 1\n  for (i in 1:14){\n    if (!is.na(r[i])){\n      if (r[i]) {j = j + 1}\n    }\n\n    s[j] = add(s[j], demands[i])\n  }\n\n  s[1] = add(s[1], s[j])\n  s    = s[-j]\n  # if (is.na(q)){return(sd(s))} else {return(sum((s - q) > 0)*1000000 + mean((q - s)^2))}\n\n  if (is.na(q)){return(sd(s))} else {\n    cost = mean((q - s)^2) + roster.cost.sim(r, q, demands = demands)\n    return(cost)\n  }\n}\n\n\n# r: fortnight roster\n# p: pernalty\n# q: order(replenishment) amount\nroster.cost.sim = function(r, q, p = 1000*q, oc = 133, hcr = 0.0225/365, demands = rep(1.0, 14)){\n  r[is.na(r)] <- 0\n  assert(sum(r) > 0, \"Given roster adds up to zero\")\n  r     = as.logical(r)\n  st    = which(r)[1]\n  b     = numeric()\n\n  b[st] = q - demands[st]\n  if (st < 14){for (i in (st + 1):14){b[i] = ifelse(r[i], q, b[i - 1]) - demands[i]}}\n  if (st > 1) {b[1] = ifelse(r[1],q, b[14]) - demands[1]}\n  if (st > 2) {for (i in 2:(st - 1)) {b[i] = ifelse(r[i], q, b[i - 1]) - demands[i]}}\n  b[b < 0] = p\n  cost     = sum(b*hcr) + sum(r*oc)\n  return(cost)\n}\n\n#' @export\nopt.roster = function(demands, freq = 2, q = NA, fr = c(1,1,1,1,1,NA,NA,1,1,1,1,1,NA,NA)){\n  N   = 2^length(fr[!is.na(fr)]) - 1\n  cst = numeric()\n  RST = numeric()\n  for (i in sequence(N)){\n    rst    = int.to.roster(i, fr)\n    if (is.na(freq)){\n      cst = c(cst, roster.cost(rst, q = q, demands = demands))\n      RST = rbind(RST, rst)\n    } else {\n      if (sum(rst, na.rm = T) == freq){\n        cst = c(cst, roster.cost(rst, q = q, demands = demands))\n        RST = rbind(RST, rst)\n      }\n    }\n  }\n  if (length(cst) < 1){return(rep(NA, 14))} else {\n    min.i = order(cst)[1]\n    return(RST[min.i,])\n  }\n}\n\n",
    "created" : 1475010045142.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1390538817",
    "id" : "23EFA802",
    "lastKnownWriteTime" : 1475010088,
    "last_content_update" : 1475010088845,
    "path" : "C:/Users/nimasoft/Dropbox/software/R/packages/nira.storeman/R/inv.tools.R",
    "project_path" : "R/inv.tools.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}