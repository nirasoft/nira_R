{
    "collab_server" : "",
    "contents" : "\n\n# Header\n# Filename:       virtual.store.R\n# Description:    Contains a class for simulating various inventory management strategies on a virtual store\n# Author:         Nima Ramezani Taghiabadi\n# Email :         nima.ramezani@cba.com.au\n# Start Date:     22 December 2015\n# Last Revision:  02 September 2016\n# Version:        4.6.0\n\n\n# Version History:\n\n# Version   Date            Action\n# ----------------------------------\n# 4.4.1     05 July 2016    method goto changed name to goto.active() as goto() runs the inactive method of the super class: TIME.SERIES\n# 4.4.2     05 July 2016    forec and fserr transferred as extra columns of data\n# 4.4.3     05 July 2016    method cost.piuno() changed. It now, subtracts the before-replenishment part of usage on the order date from the previous estimate of balance when estimating the cost\n# 4.4.4     05 July 2016    method clearFutureForecasts() added\n# 4.4.5     18 July 2016    A logical column named as 'submitted' is added to the data structure showing which orders have been submitted.\n#                           Pre-filled by True for all history data and False for calls to set.order() in optimization.\n# 4.4.6     18 July 2016    A logical argument named as 'submit' (default False) added to method set.order()\n# 4.4.7     18 July 2016    A logical argument named as 'submited_only' (default False) added to method last.order()\n# 4.4.8     18 July 2016    Method jump.optimal() changed\n# 4.4.9     18 July 2016    method gen.report() eliminated\n# 4.4.10    18 July 2016    A character column named as 'Order.Date' is added to the data structure showing the time stamp in which the order is set or submitted.\n# 4.4.11    18 July 2016    method set.order() modified and now fills column 'Order.Date'\n# 4.4.12    18 July 2016    All data column names now start with capitals and order.return renamed to Return\n# 4.4.13    29 July 2016    Adjusted Demand added taking into account the availability data\n# 4.4.14    03 August 2016  Method jump.optimal() modified: Orders can never be set on forbidden days.\n# 4.4.15    15 August 2016  Method recommend.order() modified: When only_fontial is TRUE, the function does not return NULL if next day is a forbidden day.\n#                           This modification is required in association with change made in version 4.4.14\n# 4.4.16    15 August 2016  Method next.order.report() modified: Usage includes both the first and next order days and all days between them\n#                           respecting ard ratios on the first and next order days.\n# 4.4.17    19 August 2016  Some errors in Method cost.piuno() fixed.\n# 4.4.18    19 August 2016  In method recommend.orders(), if cost is greater than penalty, the loop breaks and 'j.min' next intervals is selected for the next service\n# 4.5.0     30 August 2016  Setting property 'nDaysAhead' added. Specifies number of days to predict ahead each time forecast values are missing. Default is 60.\n# 4.5.1     30 August 2016  Methods predict.demand(), predict.demand.serr(), predict.balance() and predict.balance.serr(0 eliminated\n# 4.5.1     30 August 2016  Figure 'Demand.Adjusted'renamed to 'Demand.Adj'\n# 4.5.2     30 August 2016  Default forecast is defined for figure 'Demand.Adj' as an abstract instance of class TSP.MODEL()\n# 4.6.0     02 Spetember 2016 Method updateDemandForecast() added.\n\n\n# --- --- --- --- --- --- -\n#' @export VS.SETTINGS\n#' @exportClass VS.SETTINGS\nVS.SETTINGS <- setRefClass(\"VS.SETTINGS\", fields = list(\n  capacity     = 'numeric',\n  order.capacity = 'numeric',\n  order.fee   = 'numeric',\n  order.weight = 'numeric',\n  order.roster = 'logical',\n  hc.rate      = 'numeric',\n  lead.time    = 'integer',\n  max.off.srv  = 'integer',\n  nDaysAhead   = 'integer',\n  es.penalty   = 'numeric',\n  top.up       = 'numeric',\n  serr.gain    = 'numeric',\n  base.stock   = 'numeric'), methods = list(\n    # Ordering Roster Data\n    # todo: order.fee may not be flat, support order cost per good\n    # todo: support for the other return policy (No return)\n\n    apply.roster.fortnightly = function(time, start, end, f_rost, in_roster_fee, off_roster_fee, in_roster_weight = NA, off_roster_weight = NA){\n      # Changes the roster plan, costs and weights based on the given order rules.\n      # todo: should change from ctn to N.int, currently changes the roster for all the life time\n      # Verifying in_roster_fee:\n      assert(in_roster_fee >= 0.0, \"Argument 'in_roster_fee' cannot be negative!\", err_src = match.call()[[1]])\n      peri = start:end\n      if (is.na(in_roster_weight)){in_roster_weight = in_roster_fee}\n      if (is.na(off_roster_weight)){off_roster_weight = off_roster_fee}\n      f_rost     = as.logical(f_rost)\n      ord.roster = f_rost\n      ord.cost   = in_roster_fee*f_rost\n      ord.weight = in_roster_weight*f_rost\n\n      # Emergencies:\n      ord.cost[f_rost == 0]   = off_roster_fee\n      ord.weight[f_rost == 0] = off_roster_weight\n\n      order.fee[peri]    <<- date.adjust(ord.cost, time[peri])\n      order.roster[peri] <<- date.adjust(ord.roster, time[peri])\n      order.weight[peri] <<- date.adjust(ord.weight, time[peri])\n    },\n\n    apply.roster = function(rost, in_roster_fee, off_roster_fee, in_roster_weight = NA, off_roster_weight = NA){\n      # Changes the roster plan, costs and weights based on the given roster.\n      # todo: should change from ctn to N.int, currently changes the roster for all the life time\n      # Verifying in_roster_fee:\n      assert(in_roster_fee >= 0.0, \"Argument 'in_roster_fee' cannot be negative!\", err_src = match.call()[[1]])\n      verify(rost, c(\"logical\", \"numeric\", \"integer\"), lengths = length(order.fee), varname = 'rost')\n      names(rost) <- names(in_roster_fee)\n\n      if (is.na(in_roster_weight)){in_roster_weight = in_roster_fee}\n      if (is.na(off_roster_weight)){off_roster_weight = off_roster_fee}\n      rost       = as.logical(rost)\n      order.fee   <<- in_roster_fee*rost\n      order.weight <<- in_roster_weight*rost\n\n      # Emergencies:\n      order.fee[!rost]    <<- off_roster_fee\n      order.weight[!rost] <<- off_roster_weight\n      order.roster        <<- rost\n    },\n\n    get.fortnightly.roster = function(time){\n      dof = fday(time)\n      x   = data.frame(cost = order.fee, weight = order.weight, roster = order.roster)\n      R   = aggregate(x, by = list(f.day = dof), FUN = mean)\n      rownames(R) = R[, 1]\n      R[,-1]\n    },\n\n    get.weekly.roster = function(time){\n      dow = dayOfWeek(time)\n      x   = data.frame(cost = order.fee, weight = order.weight, roster = order.roster)\n      R   = aggregate(x, by = list(week.day = dow), FUN = mean)\n      rownames(R) = R[, 1]\n      R[,-1]\n    },\n\n    forbid.weekends = function(time, cost = NA, weight = NA){\n      # assert length(time) == length(order.weight)\n      forbidden = dayOfWeek(time) %in% c('Sat', 'Sun')\n      order.roster[forbidden] <<- NA\n      if (!is.na(cost)){order.fee[forbidden] <<- cost}\n      if (!is.na(weight)){order.weight[forbidden] <<- weight}\n    }\n  ))\n\ndefault.vs.settings <<- VS.SETTINGS(\n  capacity       = 10000,\n  order.capacity = Inf,\n  hc.rate        = 0.01/365,\n  lead.time    = as.integer(1),\n  es.penalty   = 10,\n  max.off.srv  = as.integer(60),\n  nDaysAhead   = as.integer(60),\n  serr.gain    = 1.0,\n  top.up       = 0,\n  base.stock   = 0)\n\n\n#' @include inv.tools.R\n\n# Creating a VIRTUAL.STORE class\n#' A Reference Class representing a store or inventory.\n#'\n#' @field N.int An integer representing the number of time intervals in the time series\n#' @field ctn An integer representing the current time interval number\n#' @field stn An integer representing the starting time interval number of the control window\n#' @field etn An integer representing the end time interval number of the control window\n#' @export VIRTUAL.STORE\n#' @exportClass VIRTUAL.STORE\nVIRTUAL.STORE <- setRefClass(\"VIRTUAL.STORE\", contains = 'TIME.SERIES',\n                             fields = list(\n                               address    = \"character\",\n                               ard.ratio  = \"numeric\",\n                               initial.balance = \"numeric\",\n                               settings   = \"VS.SETTINGS\"\n                             ),\n\n                             methods = list(\n                               initialize = function(timeset = NULL, demandset = NULL, orderset = NULL, initial_balance = 0, vs_settings = NULL, ard_ratio = NULL, availability = NULL, ...){\n                                 # Argument verifications:\n                                 timeset   = verify(timeset, valid.time.classes)\n\n                                 if (is.null(timeset) | (length(timeset) == 0)){\n                                   callSuper(timeset = NULL, dataset = NULL, ...)\n                                 } else {\n                                   N  = length(timeset)\n                                   # Argument verifications:\n                                   settings <<- verify(vs_settings, \"VS.SETTINGS\", varname = \"vs_settings\", default = default.vs.settings)\n\n                                   demandset = verify(demandset, c('integer', 'numeric'), range = c(0, 10*settings$capacity), lengths = N, varname = \"demandset\")\n                                   orderset  = verify(orderset,  c('integer', 'numeric'), range = c(0, 20*settings$order.capacity), lengths = N, varname = \"orderset\") # change it later to 1.0\n                                   initial_balance <- verify(initial_balance, c(\"integer\", \"numeric\"), lengths = 1, range = c(0, 10*settings$capacity), varname = \"initial_balnce\")\n                                   if (is.null(initial_balance)){initial.balance <<- 0} else {initial.balance <<- as.numeric(initial_balance)}\n\n                                   ard_ratio = verify(ard_ratio, c('numeric'), range = c(0, 1), lengths = N)\n                                   if (is.null(ard_ratio)){ard.ratio <<- rep(0.5, N)} else {ard.ratio <<- ard_ratio}\n                                   if (!is.null(availability)){\n                                     assert(length(availability) == N, \"Argument 'avaialability' does not match length!\" )\n                                     data$Availability <<- availability\n                                   }\n                                   ard.ratio[is.na(ard.ratio)] <<- mean(ard.ratio, na.rm = T)\n\n                                   # Set defaults for optional columns and assign fields:\n                                   if (is.null(orderset)){orderset <- rep(0, N)}\n\n                                   dataset = data.frame(\n                                     Demand       = demandset,\n                                     Order        = orderset,\n                                     Order.Date   = rep(NA, N),\n                                     Balance      = rep(NA, N),\n                                     Return       = rep(NA, N),\n                                     Hold.Cost    = rep(NA, N),\n                                     Order.Cost   = rep(NA, N),\n                                     Total.Cost   = rep(NA, N),\n                                     Availability = rep(NA, N),\n                                     Demand.Adj = rep(NA, N),\n                                     forec        = rep(NA, N),\n                                     fserr        = rep(NA, N),\n                                     Submitted    = rep(TRUE, N),\n                                     stringsAsFactors = F)\n\n                                   callSuper(dataset = dataset, timeset = timeset, ...)\n\n                                   # todo: transfer to the validity method of class VS.SETTINGS\n                                   # err.lead.time = make.err.msg(\"lead_time can not be negative\", err_src = match.call()[[1]])\n                                   # assert(settings$lead.time >= 0, err.lead.time)\n                                   if (is.null(vs_settings)){settings$apply.roster.fortnightly(time, f_rost = c(T,T,T,T,T,T,T,T,T,T,T,T,T,T), in_roster_fee = 0, off_roster_fee = 0, in_roster_weight = 1, off_roster_weight = 1)}\n                                   # forecast[['Demand.Adj']] <<- TSP.MODEL(seasonalities = c('moy'))\n                                   forecast[['Demand.Adj']] <<- TSP.MODEL(seasonalities = character())\n                                   update(1)\n                                   adjust.demand()\n                                 }\n                               },\n\n                               adjust.demand = function(threshold_high = 0.8, threshold_low = 0.2){\n                                 missing = which(is.na(data$Availability))\n                                 high    = which(data$Availability >= threshold_high)\n                                 low     = which((data$Availability >= threshold_low) & (data$Availability < threshold_high))\n                                 zero    = which(data$Availability < threshold_low)\n\n                                 s       = aggregate(data$Demand, by = list(DOW = dayOfWeek(time)), FUN = max)\n                                 rownames(s) <- s$DOW\n\n                                 data$Demand.Adj[missing] <<- data$Demand[missing]\n                                 data$Demand.Adj[high]    <<- data$Demand[high]/data$Availability[high]\n                                 for (i in low){\n                                   data$Demand.Adj[i]    <<- max(data$Demand[i], min(data$Demand[i]/data$Availability[i], s[dayOfWeek(time[i]), 'x']))\n                                 }\n\n                                 for (i in zero){\n                                   data$Demand.Adj[i]    <<- max(0.5*data$Demand[i]/threshold_low, s[dayOfWeek(time[i]), 'x'])\n                                 }\n                               },\n\n                               reset = function(){\n                                 stn <<- ctn\n                                 if (ctn > 1){\n                                   data$Hold.Cost[ctn] <<- data$Balance[ctn]*settings$hc.rate\n                                   data$Order.Cost[ctn]   <<- (data$Order[ctn] > 0)*settings$order.fee[ctn]\n                                   if (is.na(data$Order.Cost[ctn])){data$Order.Cost[ctn] <<- 0}\n                                   data$Total.Cost[ctn]   <<- data$Hold.Cost[ctn] + data$Order.Cost[ctn]\n                                 }\n                               },\n\n                               # removes missing values from time series\n                               remove.missing = function(give_missing = F, ...){\n                                 misindex = callSuper(..., give_missing = T)\n                                 ard.ratio             <<- ard.ratio[!misindex]\n                                 settings$order.fee   <<- settings$order.fee[!misindex]\n                                 settings$order.weight <<- settings$order.weight[!misindex]\n                                 settings$order.roster <<- settings$order.roster[!misindex]\n                               },\n\n                               extend = function(..., period = 86400, vs_settings = NULL, R = NULL, forecast_demand = T, demands = NULL, orders = NULL){\n                                 m = N.int\n                                 callSuper(period = period, ...)\n                                 data$Order[(m + 1):N.int] <<- 0\n                                 if (is.null(vs_settings)){\n                                   if(is.null(R)){R = settings$get.fortnightly.roster(time = time)}\n                                   dof = fday(time)\n                                   dof = dof[(m + 1):N.int]\n                                   nr  = rep(NA, length(dof)) # new roster\n                                   nc  = rep(NA, length(dof)) # new costs\n                                   nw  = rep(NA, length(dof)) # new weigthts\n                                   for (fd in rownames(R)){\n                                     nr[dof == fd ] = R[fd, 'roster']\n                                     nw[dof == fd ] = R[fd, 'weight']\n                                     nc[dof == fd ] = R[fd, 'cost']\n                                   }\n                                   settings$order.roster <<- c(settings$order.roster, as.logical(nr))\n                                   settings$order.weight <<- c(settings$order.weight, nw)\n                                   settings$order.fee   <<- c(settings$order.fee, nc)\n                                 } else {\n                                   verify(vs_settings, 'VS.SETTINGS', varname = 'settings')\n                                   dates = rownames(data)\n                                   verify(vs_settings$order.roster, names_include = dates, varname = 'vs_settings$order.roster')\n                                   verify(vs_settings$order.fee, names_include = dates, varname = 'vs_settings$order.fee')\n                                   verify(vs_settings$order.weight, names_include = dates, varname = 'vs_settings$order.weight')\n\n                                   settings$order.roster[dates]  <<- vs_settings$order.roster[dates]\n                                   settings$order.fee[dates]     <<- vs_settings$order.fee[dates]\n                                   settings$order.weight[dates] <<- vs_settings$order.weight[dates]\n                                 }\n                                 ard.ratio             <<- c(ard.ratio, rep(ard.ratio[m], N.int - m))\n\n                                 if (forecast_demand){\n                                   forecast.arima(figure = 'Demand.Adj', from = ctn + 1, jumper = N.int - ctn + 2)\n                                   peri = (ctn + 1):N.int\n                                   tc = as.character(time[peri])\n                                   data$forec[peri] <<- forecast[['Demand.Adj']]$pred[tc]\n                                   data$fserr[peri] <<- settings$serr.gain*forecast[['Demand.Adj']]$serr[tc]\n                                   data$forec[peri][data$forec[peri] < 0] <<- 0\n                                 }\n\n                                 peri = (m + 1):N.int\n\n                                 if (sum(is.na(data$forec[peri])) == 0){etn <<- N.int}\n\n                                 if (!is.null(demands)){\n                                   verify(demands, c('integer','numeric'), lengths = N.int - m)\n                                   assert(feasible(demands), \"Given demand values are not feasible! Check for missing values.\", err_src = match.call()[[1]])\n                                   data$Demand[peri] <<- demands\n                                 }\n\n                                 if (!is.null(orders)){\n                                   verify(orders, c('integer','numeric'), lengths = N.int - m)\n                                   assert(feasible(orders), \"Given order values are not feasible! Check for missing values.\", err_src = match.call()[[1]])\n                                   data$Order[peri] <<- orders\n                                 } else {data$Order[peri] <<- 0}\n                               },\n\n                               subset = function(period = stn:etn, settings = settings){\n                                 if (class(period) %in% c('numeric', 'integer')){sort(period)}\n                                 if (is.na(data$Balance[period[1]])){jump(period[1])}\n                                 VIRTUAL.STORE(timeset = time[period], demandset = data$Demand[period], orderset = data$Order[period],\n                                               initial_balance = data$Balance[period[1]], vs_settings = settings)\n                               },\n\n                               set.order = function(amount = NA, N.next = settings$lead.time, persist = TRUE, submit = FALSE){\n                                 # If order is set, the day number in which order is set is returned otherwise FALSE is returned\n                                 # Check Input Arguments:\n                                 err.amount.neg = make.err.msg(\"Negative value chained to argument amount\", err_src = match.call()[[1]])\n                                 assert (amount >= 0, err.amount.neg)\n                                 if (N.next < settings$lead.time){\n                                   print(\"Warning: N.next is lower than lead_time! Changed to lead_time.\")\n                                   N.next = settings$lead.time\n                                 }\n\n                                 dtn = ctn + N.next # Delivery Time Number\n                                 if (dtn > N.int){return(FALSE)}\n                                 # Make sure order time is not a restricted date-time:\n                                 while (is.na(settings$order.roster[dtn]) & (dtn < N.int) & persist){N.next = N.next + 1}\n                                 if (!is.na(settings$order.roster[dtn])){\n                                   mx = min(N.int, dtn + settings$lead.time)\n                                   data$Order[(ctn + 1):mx] <<- 0\n                                   data$Order[dtn]      <<- min(settings$order.capacity, roundto.multiple(amount + settings$top.up, 2000, adjust = 'top'))\n                                   data$Submitted[dtn]  <<- submit\n                                   data$Order.Date[dtn] <<- as.character(time[ctn])\n                                   return(dtn)\n                                 } else {return(FALSE)}\n                               },\n\n                               fit.fortnight.roster = function(period = stn:ctn, threshold = 0.8, forbid_weekends = T){\n                                 roster = rep(0, 14)\n                                 if (forbid_weekends){roster[c(6,7,13,14)] = NA}\n                                 names(roster) = fdlabel\n\n                                 foc = fortnight.order.counts(period = period)\n\n                                 ttc = tab.top.cumulative(foc, threshold = threshold)\n                                 roster[ttc] = 1\n                                 # roster[names(roster) %in% ttc] = 1\n                                 roster = as.logical(roster)\n                                 names(roster) = fdlabel\n                                 return(roster)\n                               },\n\n                               close.order = function(N.next = 1){\n                                 # I tested, only the first line is read/use markdown format\n                                 \"\n                                 Closes all orders \\n\n                                 \\n\n                                 Arguments: \\n\n                                 N.next integer specifies the number of time intervals after the current time interval on which the order must be closed  \\n\n                                 Returns: closes the order on the specified time interval \\n\n                                 Example: \\n\n                                 x$close.order(5) \\n\n                                 \"\n                                 dtn = ctn + N.next\n\n                                 err.order.np = make.err.msg(\"Order is not possible for the specified date\", err_src = match.call()[[1]])\n                                 assert ( dtn <= N.int, err.order.np)\n                                 data$Order[ctn + N.next] <<- amount\n                               },\n\n                               fill.rate = function(threshold = settings$base.stock){\n                                 threshold = threshold + 0.0001\n                                 return(1.0 - sum(data$Balance[stn:ctn] < threshold)/(ctn - stn + 1))\n                               },\n\n                               holding.cost  = function(){return(sum(data$Balance[stn:ctn]*settings$hc.rate))},\n\n                               ordering.cost = function(){return(sum((data$Order[stn:ctn] > 0)*settings$order.fee[stn:ctn], na.rm = TRUE))},\n\n                               # Note: interval i-1 must have been updated prior to running this method for i\n                               update = function(i){\n\n                                 if (i == 1){\n                                   if (data$Order[i] == 0){\n                                     data$Balance[i]      <<- max(0, initial.balance - data$Demand[i])\n                                     data$Return[i] <<- 0\n                                     data$Order.Cost[i]   <<- 0\n                                   } else {\n                                     stock    = data$Order[i] + initial.balance - data$Demand[i]*(1.0 - ard.ratio[i])\n                                     trimmed  = min(stock, settings$capacity)\n                                     data$Balance[i]      <<- max(0, trimmed - data$Demand[i]*ard.ratio[i])\n                                     data$Return[i] <<- stock - trimmed\n                                     data$Order.Cost[i]   <<- settings$order.fee[i]\n                                   }\n                                   data$Hold.Cost[i] <<- settings$hc.rate*data$Balance[i]\n                                 } else{\n                                   if (is.na(data$Demand[i])){data$Demand[i] <<- min(data$forec[i], data$Balance[i - 1])}\n                                   if (data$Order[i] == 0){\n                                     data$Balance[i]      <<- max(0, data$Balance[i - 1] - data$Demand[i])\n                                     data$Return[i] <<- 0\n                                     data$Order.Cost[i]   <<- data$Order.Cost[i - 1]\n                                   } else {\n                                     stock    = data$Order[i] + data$Balance[i - 1] - data$Demand[i]*(1.0 - ard.ratio[i])\n                                     trimmed  = min(stock, settings$capacity)\n                                     data$Balance[i]      <<- max(0, trimmed - data$Demand[i]*ard.ratio[i])\n                                     data$Return[i] <<- stock - trimmed\n                                     data$Order.Cost[i]   <<- data$Order.Cost[i - 1] + settings$order.fee[i]\n                                   }\n                                   data$Hold.Cost[i] <<- data$Hold.Cost[i - 1] + settings$hc.rate*data$Balance[i]\n                                 }\n                                 data$Total.Cost[i]   <<- data$Hold.Cost[i] + data$Order.Cost[i]\n                               },\n\n                               cost.piuno = function(Q, N){\n                                 # cpiuno: Cost per interval until the next order\n                                 # If the store is replenished the next N time intervals (days) with Q amount of goods,\n                                 # how much is the cost per time interval(day) from now until the nect N intervals\n                                 # According to the cur status of the store, this function returns the expected cost if first replenishment is done N days(intervals) after cur time\n                                 # For example if N = 1 it returns the expected cost if replenishment takes place tomorrow\n                                 # the cost is estimated per unit time(day) until the first interval after the next replenishment from cur time\n                                 # taking property settings$lead.time and settings$order.roster into considerations. If replenishment if not possible after N days NA is returned\n                                 if ((N < settings$lead.time) | is.na(settings$order.roster[N + ctn])){return(NA)}\n                                 if (N > 1){\n                                   FD = data$forec[(ctn+1):(ctn+N-1)]\n                                   FE = data$fserr[(ctn+1):(ctn+N-1)]\n                                   if (sum(is.na(FD+FE))>0){\n                                     updateForecast('Demand.Adj')\n                                     res = predictNext(N - 1 + settings$nDaysAhead, 'Demand.Adj', 'arima')\n                                     tcx = names(res$pred)\n                                     data[tcx, 'forec'] <<- res$pred\n                                     data[tcx, 'fserr'] <<- res$serr*settings$serr.gain\n                                     data[tcx, 'forec'][data[tcx, 'forec'] < 0] <<- 0\n                                     FD = data$forec[(ctn+1):(ctn+N-1)]\n                                     FE = data$fserr[(ctn+1):(ctn+N-1)]\n                                   }\n                                   mu = c()\n                                   sd = c()\n                                   ss = 0\n                                   B  = current('Balance')\n                                   for (i in 1:(N-1)){\n                                     B  = B - FD[i]\n                                     mu = c(mu, B)\n                                     ss = ss + FE[i]*FE[i]\n                                     sd = c(sd, sqrt(ss))\n                                   }\n                                   cost.before = (N - 1)*futureCostsPI(N = N - 1, B = current('Balance'), mu = mu, sigma = sd, P = settings$es.penalty, h = settings$hc.rate, base = settings$base.stock)\n                                 } else {cost.before = 0}\n\n                                 cost.after   = Q*settings$hc.rate  + settings$order.weight[N + ctn]\n                                 return((cost.before + cost.after)/N)\n                               },\n\n                               cost.piuno.2 = function(Q, N){\n                                 # cpiuno: Cost per interval until the next order\n                                 # If the store is replenished the next N time intervals (days) with Q amount of goods,\n                                 # how much is the cost per time interval(day) from now until the nect N intervals\n                                 # According to the cur status of the store, this function returns the expected cost if first replenishment is done N days(intervals) after cur time\n                                 # For example if N = 1 it returns the expected cost if replenishment takes place tomorrow\n                                 # the cost is estimated per unit time(day) until the first interval after the next replenishment from cur time\n                                 # taking property settings$lead.time and settings$order.roster into considerations. If replenishment if not possible after N days NA is returned\n                                 if ((N < settings$lead.time) | is.na(settings$order.roster[N + ctn])){return(NA)}\n                                 if (N > 1){\n                                   sqn = sequence(N)\n                                   FD  = data$forec[ctn + sqn]\n                                   FE  = data$fserr[ctn + sqn]\n                                   if (sum(is.na(FD+FE))>0){\n                                     updateForecast('Demand.Adj')\n                                     res = predictNext(N + settings$nDaysAhead, 'Demand.Adj', 'arima')\n                                     tcx = names(res$pred)\n                                     data[tcx, 'forec'] <<- res$pred\n                                     data[tcx, 'fserr'] <<- res$serr*settings$serr.gain\n                                     data[tcx, 'forec'][data[tcx, 'forec'] < 0] <<- 0\n                                     FD = data$forec[(ctn+1):(ctn+N-1)]\n                                     FE = data$fserr[(ctn+1):(ctn+N-1)]\n                                   }\n                                   mu = c()\n                                   sd = c()\n                                   ss = 0\n                                   B  = current('Balance')\n                                   for (i in sequence(N)){\n                                     B  = B - (1.0 - ard.ratio[ctn + i])*FD[i]\n                                     mu = c(mu, B)\n                                     B  = B - ard.ratio[ctn + i]*FD[i]\n                                     ss = ss + FE[i]*FE[i]\n                                     sd = c(sd, sqrt(ss))\n                                   }\n                                   cost.before = N*futureCostsPI(N = N, B = current('Balance'), mu = mu, sigma = sd, P = settings$es.penalty, h = settings$hc.rate, base = settings$base.stock)\n                                 } else {cost.before = 0}\n\n                                 FDN = data$forec[ctn+N]\n                                 if (is.na(FDN)){FDN = predict.demand(N)}\n                                 FDN = FDN*ard.ratio[N + ctn]\n                                 cost.after   = (Q - FDN)*settings$hc.rate  + settings$order.weight[N + ctn]\n                                 return((cost.before + cost.after)/N)\n                               },\n\n                               next.order.opportunities = function(N.next){\n                                 err.nahead = make.err.msg(\"Argument 'N.next' must be greater than 'settings$lead.time'\" , err_src = match.call()[[1]])\n                                 assert(N.next > settings$lead.time, err.nahead)\n\n                                 if (ctn + settings$lead.time > N.int){return(c())}\n\n                                 period = (ctn + settings$lead.time):(min(N.int, ctn + N.next))\n                                 flag   = is.na(settings$order.roster[period])\n                                 return (period[! flag])\n                               },\n\n                               roster.days  = function(from = NA, until = NA){\n                                 if (is.na(from)){from = ctn + settings$lead.time}\n                                 if (is.na(until)){until = N.int}\n\n                                 if (from > N.int){return(c())}\n                                 if (until > N.int){until = N.int}\n\n                                 assert((from > 0) & (until >= from), \"Argument 'until' must be after 'from'\", match.call()[[1]])\n\n                                 period = from:until\n                                 flag   = (settings$order.roster[period] == 0) | (is.na(settings$order.roster[period]))\n                                 return (period[! flag])\n                               },\n\n                               free.days  = function(from = NA, until = NA){\n                                 if (is.na(from)){from = ctn + settings$lead.time}\n                                 if (is.na(until)){until = N.int}\n\n                                 if (from > N.int){return(c())}\n                                 if (until > N.int){until = N.int}\n\n                                 assert((from > 0) & (until >= from), \"Argument 'until' must be after 'from'\", match.call()[[1]])\n\n                                 period = from:until\n                                 flag   = is.na(settings$order.roster[period])\n                                 return (period[! flag])\n                               },\n\n                               fortnight.order.counts = function(period = stn:ctn){\n                                 FDY    = fday(time)[period]\n                                 t      = tabulate(1 + FDY[which(data$Order[period] > 0)])\n                                 fc     = c(t[-1], rep(0, 14 - length(t)), t[1])\n                                 names(fc) = fdlabel\n                                 return(fc)\n                               },\n\n                               ggvis.plot = function(period, figure, width = 760, height = 300){\n                                 xvar <- prop(\"x\", as.symbol('time'))\n                                 yvar <- prop(\"y\", as.symbol(figure))\n\n                                 xvar_name <- 'Date'\n                                 yvar_name <- figure\n\n                                 # p <- ggvis(to.data.frame(period, figure), x = xvar, y = yvar, key := ~ID)\n\n                                 p <- ggvis(to.data.frame(period, figure), x = xvar, y = yvar)\n                                 p <- layer_points(p, size.hover := 200) %>% scale_datetime(\"x\", nice = \"month\")\n                                 if (figure %in% c('Balance', 'Demand', 'Hold.Cost', 'Order.Cost', 'Total.Cost')){p <- layer_paths(p)}\n                                 p <- p %>% add_axis('x', title = xvar_name)  %>%\n                                   add_axis('y', title = yvar_name, title_offset = 70)  %>%\n                                   set_options(width = width, height = height)\n                                 return(p)\n                               },\n\n                               goto.active = function(Time){\n                                 # Takes you to the given time.num\n                                 # The given time.num must be in the future. (More than the cur time.num)\n                                 # This function respects the orders and actual demands set for the dates between curent time and the specified time_num in the future\n                                 # in calculating the balance\n                                 # Check if the given time.num is greater than the cur\n                                 ktn = ctn # keep the current time number in ktn\n                                 goto(Time)\n                                 if (ctn > etn){ctn <<- etn}\n                                 if (ktn >= ctn){\n                                   data[(ctn + 1):etn,c('Balance', 'Return', 'Hold.Cost', 'Order.Cost', 'Total.Cost')] <<- as.numeric(NA)\n                                 } else {\n                                   for (i in (ktn + 1):ctn){update(i)}\n                                 }\n                                 # forecast[['Demand.Adj']]$train(time[2:ctn], data$Demand[2:ctn], model_type = 'mean')\n                                 # todo: write method update() to fasten this process\n                               },\n\n                               jump.active = function(N_int = 1){\n                                 # jumps to the next <<N.int>> interval\n                                 goto.active(ctn + N_int)\n                               },\n\n                               #     predict.demand = function(peri){\n                               #       peri.ext = (ctn + 1):min(ctn + max(peri) + settings$nDaysAhead, N.int)\n                               #       times    = time[peri.ext]\n                               #       if (class(forecast[['Demand.Adj']]) == 'NULL'){forecast[['Demand.Adj']] <<- TSP.MODEL(seasonalities = 'moy')}\n                               #       f      = forecast[['Demand.Adj']]\n                               #       demdat = data$Demand.Adj[sequence(ctn)]\n                               #       findex = which(feasible(demdat))\n                               #\n                               #       assert(length(findex) > 7, \"Requires at least seven history values for demand!\", err_src = match.call()[[1]])\n                               #       cat('Predicting usage from ', as.character(times[1]), ' until ',  as.character(times[length(times)]), ' ... ')\n                               #       if (!identical(f$train.time, time[findex])){\n                               #         f$train(time = time[findex], data = demdat[findex])\n                               #       }\n                               #       res = f$predict(times)\n                               #       data$forec[peri.ext] <<- res$pred\n                               #       data$fserr[peri.ext] <<- settings$serr.gain*res$serr\n                               #       data$forec[peri.ext][data$forec[peri.ext] < 0] <<- 0\n                               #       cat('Done! \\n')\n                               #       return(data$forec[ctn + peri])\n                               #     },\n                               #\n                               #     predict.demand.serr = function(peri){\n                               #       if (sum(is.na(data$fserr[ctn + peri])) > 0){predict.demand(peri)}\n                               #       return(data$fserr[ctn + peri])\n                               #     },\n\n                               updateDemandForecast = function(){\n                                 updateForecast('Demand.Adj')\n                                 res = predictNext(settings$nDaysAhead, 'Demand.Adj', 'arima')\n                                 tcx = names(res$pred)\n                                 data[tcx, 'forec'] <<- res$pred\n                                 data[tcx, 'fserr'] <<- res$serr*settings$serr.gain\n                                 data[tcx, 'forec'][data[tcx, 'forec'] < 0] <<- 0\n                               },\n\n\n                               next.order.report.1 = function(N1, N2){\n                                 # if you want to do the next order the next N1 days:\n                                 # 1- how much should you replensih if the next replenishment is N2 days after this order\n                                 # 2- how much is the daily cost until the next replenishment after this order (N1 + N2 days ahead)\n                                 FD  = data$forec[(ctn+N1):(ctn+N1+N2-1)]\n                                 FE  = data$fserr[(ctn+N1):(ctn+N1+N2-1)]\n                                 if (sum(is.na(FD+FE))>0){\n                                   updateForecast('Demand.Adj')\n                                   res = predictNext(N1 + N2 + settings$nDaysAhead, 'Demand.Adj', 'arima')\n                                   tcx = names(res$pred)\n                                   data[tcx, 'forec'] <<- res$pred\n                                   data[tcx, 'fserr'] <<- res$serr*settings$serr.gain\n                                   data[tcx, 'forec'][data[tcx, 'forec'] < 0] <<- 0\n                                   FD  = data$forec[(ctn+N1):(ctn+N1+N2-1)]\n                                   FE  = data$fserr[(ctn+N1):(ctn+N1+N2-1)]\n                                 }\n                                 QQ  = sum(FD[1:N2]) + settings$base.stock + 3.0*sqrt(sum(FE[1:N2]^2))\n                                 out = list(amount = QQ, cost = (sum((QQ - cumulative(FD[1:N2]))*settings$hc.rate) + settings$order.weight[ctn + N1 + N2])/N2)\n                                 return(out)\n                               },\n\n                               next.order.report = function(N1, N2){\n                                 # if you want to do the next order the next N1 days:\n                                 # 1- how much should you replensih if the next replenishment is N2 days after this order\n                                 # 2- how much is the daily cost until the next replenishment after this order (N1 + N2 days ahead)\n                                 assert(N2 > 0)\n                                 rr  = c(ard.ratio[ctn+N1], rep(1.0, N2 - 1), 1.0 - ard.ratio[ctn+N1+N2])\n                                 FD  = rr*data$forec[(ctn+N1):(ctn+N1+N2)]\n                                 FE  = rr*data$fserr[(ctn+N1):(ctn+N1+N2)]\n                                 if (sum(is.na(FD+FE))>0){\n                                   updateForecast('Demand.Adj')\n                                   res = predictNext(N1 + N2 + settings$nDaysAhead, 'Demand.Adj', 'arima')\n                                   tcx = names(res$pred)\n                                   data[tcx, 'forec'] <<- res$pred\n                                   data[tcx, 'fserr'] <<- res$serr*settings$serr.gain\n                                   data[tcx, 'forec'][data[tcx, 'forec'] < 0] <<- 0\n                                   FD  = rr*data$forec[(ctn+N1):(ctn+N1+N2)]\n                                   FE  = rr*data$fserr[(ctn+N1):(ctn+N1+N2)]\n                                 }\n                                 QQ  = sum(FD) + settings$base.stock + 3*sqrt(sum(FE^2))\n                                 out = list(amount = QQ, cost = (sum((QQ - cumulative(FD))*settings$hc.rate) + settings$order.weight[ctn + N1 + N2])/N2)\n                                 return(out)\n                               },\n\n                               optimal.order.amount = function(N){\n                                 cost.min = Inf\n                                 stay     = (ctn + N <= N.int)  # must be True\n                                 err.N = make.err.msg(\"No data for the next 'N' intervals!\", err_src = match.call()[[1]])\n                                 assert(stay, err.N)\n                                 i        = 0\n                                 optim.Q  = sqrt(2*mean(settings$order.fee, na.rm = T)*mean(data$Demand, na.rm = T)/settings$hc.rate)\n                                 while ((stay) & (ctn + N + i < N.int)){\n                                   i   = i + 1\n                                   res = next.order.report(N, i)\n                                   if (!is.na(settings$order.roster[ctn + N + i])){\n                                     # cost = (i*res$cost + settings$order.weight[ctn + N + i])/(i + 1)\n                                     if (cost.min > res$cost){\n                                       cost.min = res$cost\n                                       optim.Q  = res$amount\n                                       n.raise  = 0\n                                     } else {\n                                       n.raise = n.raise + 1\n                                       stay = n.raise < 15\n                                     }\n                                   }\n                                 }\n                                 return(optim.Q)\n                               },\n\n                               minimum.order.amount = function(N){\n                                 nin = N.int\n                                 if (ctn + N + settings$lead.time > nin){return(settings$order.capacity)}\n\n                                 if (is.na(settings$order.roster[ctn + N])){return(NA)} # Is the next N-th day an order day?\n                                 else{\n                                   nop = which(!is.na(settings$order.roster[(ctn + N + settings$lead.time):N.int]))[1]\n                                   if (is.na(nop)){res = next.order.report(N, N.int - ctn - N + 1)} else {res = next.order.report(N, nop + settings$lead.time - 1)}\n                                 }\n                                 return (res$amount)\n                               },\n\n                               required.order.amount = function(N1, N2){\n                                 # If replenish the next N1 days, how much should be ordered so that next order is N2 days after that\n                                 if (ctn + N1 + settings$lead.time > N.int){return(50000)}\n                                 if (ctn + N1 + N2 > N.int){N2 = N.int - ctn - N1}\n\n                                 # Is the next N1 days an order day?\n                                 if (is.na(settings$order.roster[ctn + N1])){return(NA)}\n                                 else {res = next.order.report(N1, N2)}\n                                 return (res$amount)\n                               },\n\n                               run.forecast = function(from = 1, jumper = 10, model_type = 'mean'){\n                                 assert(jumper >= 1)\n                                 f = forecast[['Demand.Adj']]\n                                 f$reset()\n                                 i = from\n                                 while (i < N.int){\n                                   j = i + jumper\n                                   if (j > N.int){j = N.int}\n                                   f$train(time = time[1:i], data = data$Demand.Adj[1:i], model_type = model_type)\n                                   res = f$predict(time[(i + 1):j], model_type = model_type)\n                                   i   = j\n                                 }\n                               },\n\n                               last.order = function(global = F, submitted_only = F){\n                                 \"Returns the time number of the last time in which the store was serviced (replenished)\"\n                                 if (global){prd = sequence(N.int)} else {prd = sequence(ctn)}\n                                 fbl = feasible(data$Order[prd], exclude = 0)\n                                 if (submitted_only){fbl = fbl & data$Submitted[prd]}\n                                 w   = which(fbl)\n                                 if (is.empty(w)) {return(0)} else {return(w[length(w)])}\n                               },\n\n                               next.order = function(submitted_only = F){\n                                 \"Returns the time number of the next time in which the store will be serviced (replenished)\"\n                                 prd = (ctn + 1):N.int\n                                 fbl = feasible(data$Order[prd], exclude = 0)\n                                 if (submitted_only){fbl = fbl & data$Submitted[prd]}\n                                 w   = which(fbl)\n                                 if (is.empty(w)) {return(0)} else {return(ctn + w[1])}\n                               },\n\n                               # only_fontial: only for next time interval after lead time\n                               recommend.order = function(fixed_roster = FALSE, only_fontial = T){\n                                 # SECE: Sequential Expected Cost Evaluation is a new method for optimal replenishment order planning\n                                 # for store management. It recommends how much and in how many intervals in the future is optimal to replenish the store\n                                 mu  = mov.avr('Demand')\n                                 lst = last.order()\n\n                                 alt = settings$lead.time  # actual lead time\n                                 while (is.na(settings$order.roster[ctn + alt]) & (ctn + alt < N.int)){alt = alt + 1}\n\n                                 if    (is.na(settings$order.roster[ctn + alt]) & (ctn + alt == N.int)){ # No more order opportunities left\n                                   # goto(N.int)\n                                   return(NA)\n                                 }\n\n                                 j         = alt\n                                 cost.min  = Inf\n                                 j.min     = 0\n                                 stay      = (mu > 0)\n                                 n.raise   = 0\n                                 while (stay){\n                                   cost = cost.piuno(Q = settings$order.capacity, N = j) + settings$es.penalty*(j + ctn > settings$max.off.srv + lst)\n                                   if (!is.na(cost)){\n                                     if (cost < cost.min){\n                                       j.min    = j\n                                       cost.min = cost\n                                       n.raise  = 0\n                                       if (only_fontial & (j.min > alt) & !is.na(settings$order.roster[ctn + 1])){return(NULL)}\n                                     } else{\n                                       n.raise = n.raise + 1\n                                       stay    = n.raise < 15\n                                     }\n                                   }\n                                   j    = j + 1\n                                   stay = stay & (j + ctn < N.int) & (cost.min < settings$es.penalty)\n                                 }\n\n                                 flag = (mu > 0) & (j.min > 0)\n                                 if ((flag) & (n.raise == 0)){\n                                   sd    = mov.sd('Demand')\n                                   ecinr = j.min*futureCostPI(N = j.min, B = current('Balance'), mu = mu, sigma = sd, P = settings$es.penalty, h = settings$hc.rate, base = settings$base.stock)\n                                   if (j.min > 1){\n                                     ecir  = (j.min - 1)*futureCostPI(N = j.min - 1 , B = current('Balance'), mu = mu, sigma = sd, settings$es.penalty, settings$hc.rate, base = settings$base.stock)\n                                   } else {ecir = 0}\n                                   Qs    = optimal.order.amount(j.min)\n                                   ecir  = ecir + (Qs - mu)*settings$hc.rate + settings$order.weight[ctn + j.min]\n                                   flag  = (ecinr > ecir)\n                                 }\n                                 # checks future orders\n                                 if (alt > 1) {flag = flag & (sum(data$Order[(ctn + 1):(ctn + alt - 1)]) == 0)}\n                                 if (flag){\n                                   if (fixed_roster){\n                                     # This code is written for very special case when ordering is permitted but a certain roster\n                                     # in which the order costs are minimum is preferred. While replenishment in other days are permitted,\n                                     # the system tries to choose the order amount so that the next replenishment falls on the cheapest\n                                     # days or days in the roster\n\n                                     a = roster.days(from = ctn + j.min + settings$lead.time, until = N.int)\n                                     if (length(a) == 0){Qss = round(optimal.order.amount(j.min), -1)} else {\n                                       counter = 1\n                                       Q.opt   = min(optimal.order.amount(j.min), settings$order.capacity)\n                                       Qss     = required.order.amount(j.min, min(settings$max.off.srv, a[1] - ctn - j.min))\n\n                                       if (Qss - settings$base.stock - 3*sqrt(sum(data$fserr[(ctn + 1):a[1]]^2)) > settings$order.capacity){\n                                         a   = free.days(from = ctn + j.min + settings$lead.time, until = N.int)\n                                         if (length(a) == 0){Qss = round(optimal.order.amount(j.min), -1)}\n                                         else {Qss = required.order.amount(j.min, min(settings$max.off.srv, a[1] - ctn - j.min))}\n                                       }\n                                       best.Q  = Qss\n                                       while((Qss <= Q.opt) & (counter < length(a))) {\n                                         best.Q  = Qss\n                                         counter = counter + 1\n                                         Qss     = required.order.amount(j.min, min(settings$max.off.srv, a[counter] - ctn - j.min))\n                                       }\n                                       Qss = best.Q\n                                     }\n                                   } else {Qss = optimal.order.amount(j.min)}\n                                   if ((is.na(Qss)) | (Qss <= 0)){Qss = settings$order.capacity}\n                                   return(list(N.next = j.min, time = time[ctn + j.min], amount = Qss))\n                                 }\n                                 return(NA)\n                               },\n\n                               jump.optimal = function(until = NULL, fixed_roster = FALSE, show = TRUE, forecast_demand = F, update_forecast = F){\n                                 if (is.null(until)){until = etn}\n                                 end.time.num = time.number(until)\n                                 reset()\n\n                                 data$Order[(ctn + settings$lead.time):end.time.num] <<- 0\n\n                                 eval = (ctn + 1):N.int\n                                 if (forecast_demand & !no.missing(data$forec[eval]) & !no.missing(data$fserr[eval])){\n\n                                   hist = sequence(ctn)\n                                   cat('Predicting usage from ', as.character(time[eval[1]]), ' until ',  as.character(time[max(eval)]), ' ... ')\n                                   forecast[['Demand.Adj']] <<- TSP.MODEL(seasonalities = c('moy'))\n                                   # forecast[['Demand.Adj']] <<- TSP.MODEL(seasonalities = character())\n                                   forecast[['Demand.Adj']]$train(time[hist], data$Demand.Adj[hist], model_type = 'arima')\n                                   res = forecast[['Demand.Adj']]$predict(time = time[eval], model_type = 'arima')\n\n                                   tc = time2Char(time[eval])\n\n                                   data$forec[eval] <<- forecast[['Demand.Adj']]$pred[tc]\n                                   data$fserr[eval] <<- settings$serr.gain*forecast[['Demand.Adj']]$serr[tc]\n                                   data$forec[eval][data$forec[eval] < 0] <<- 0\n                                   cat('Done ! \\n')\n                                   update_forecast = F\n                                 }\n\n                                 # data$Order[(ctn + 1):end.time.num] <<- 0\n                                 while (ctn < end.time.num){\n                                   if (show){cat('Int.No:',ctn,'Time:', as.character(now()),'Bal:',current('Balance'),'\\n')}\n                                   if (!is.na(settings$order.roster[ctn])){\n                                     if (update_forecast){updateDemandForecast()}\n                                     res = recommend.order(fixed_roster = fixed_roster, only_fontial = T)\n                                     if (class(res) == 'list'){set.order(amount = res$amount, N.next = res$N.next)}\n                                   }\n                                   jump.active()\n                                 }\n                               },\n\n                               jump.optimal.1 = function(until = NULL, fixed_roster = FALSE, show = TRUE, forecast_demand = F){\n                                 if (is.null(until)){until = etn}\n                                 end.time.num = time.number(until)\n                                 reset()\n\n                                 data$Order[(ctn + settings$lead.time):end.time.num] <<- 0\n\n                                 eval = (ctn + 1):N.int\n                                 if (forecast_demand & !no.missing(data$forec[eval]) & !no.missing(data$fserr[eval])){\n\n                                   hist = sequence(ctn)\n                                   cat('Predicting usage from ', as.character(time[eval[1]]), ' until ',  as.character(time[max(eval)]), ' ... ')\n                                   forecast[['Demand.Adj']] <<- TSP.MODEL(seasonalities = c('moy'))\n                                   forecast[['Demand.Adj']]$train(time[hist], data$Demand.Adj[hist], model_type = 'arima')\n                                   res = forecast[['Demand.Adj']]$predict(time = time[eval], model_type = 'arima')\n\n                                   tc = time2Char(time[eval])\n\n                                   data$forec[eval] <<- forecast[['Demand.Adj']]$pred[tc]\n                                   data$fserr[eval] <<- settings$serr.gain*forecast[['Demand.Adj']]$serr[tc]\n                                   data$forec[eval][data$forec[eval] < 0] <<- 0\n                                   cat('Done ! \\n')\n                                 }\n\n                                 # data$Order[(ctn + 1):end.time.num] <<- 0\n                                 while (ctn < end.time.num){\n                                   if (show){cat('Int.No:',ctn,'Time:', as.character(now()),'Bal:',current('Balance'),'\\n')}\n                                   res = recommend.order(fixed_roster = fixed_roster, only_fontial = T)\n                                   if (class(res) == 'list'){set.order(amount = res$amount, N.next = res$N.next)}\n                                   jump.active()\n                                 }\n                               },\n\n                               close.all.orders = function(){\n                                 # Closes all orders\n                                 data$Order[(ctn+1):N.int] <<- 0\n                               },\n\n                               # Accessor functions:\n\n                               str = function(){\n                                 paste(\"\\n\",\n                                       \"Time Number :\", ctn, \"\\n\",\n                                       \"Time        :\", now(), \"\\n\",\n                                       \"Balance     : $\", current('Balance'), \"\\n\",\n                                       \"Total Cost  : $\", round(holding.cost() + ordering.cost(),2), \"\\n\",\n                                       \"Order Amount: $\", data$Order[ctn], \"\\n\",\n                                       \"Return      : $\", data$Return[ctn], \"\\n\")\n                               },\n\n                               clearFutureForecasts = function(){\n                                 if (ctn < N.int){\n                                   data$forec[(ctn + 1):N.int] <<- NA\n                                   data$fserr[(ctn + 1):N.int] <<- NA\n                                 }\n                               }\n\n                             ))\n\n# Generic Functions\nprint.VIRTUAL.STORE = function(obj){\n  cat(obj$str())\n}\n\n\n# coercion method:\nsetAs(\"VIRTUAL.STORE\", \"data.frame\", function(from){\n  return(from$to.data.frame())\n})\n",
    "created" : 1475010453254.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4119371700",
    "id" : "DF05D1D0",
    "lastKnownWriteTime" : 1475010487,
    "last_content_update" : 1475010487237,
    "path" : "C:/Users/nimasoft/Dropbox/software/R/packages/nira.storeman/R/virtual.store.R",
    "project_path" : "R/virtual.store.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}